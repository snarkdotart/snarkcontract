@startuml

title Sequence Diagram: Loan

actor Borrower
control BContract
database BStorage
control API
actor Owner

== CreateLoan ==

Borrower -> BContract: create loan
BContract -> BStorage: create new record of loan
BContract -> BStorage: loan status = Prepairing
BContract -> BStorage: put all tokens into the NotApproved list

loop number tokens
  BContract -> BStorage: arrange tokens among three\nlists of different loan states
end

BContract -> API: emit event LoanCreated
API -> Owner: send an email to the token owner\nif the tokens are\nin the NotApproved list

== ApproveTokenOfLoan ==

Owner -> BContract: Approve Loan
BContract -> BStorage: check token's calendar
BContract -> BStorage: assign token to one of\nthe three lists of loan states
BContract -> BStorage: delete loan requests from the owner's list
BContract -> BStorage: if NotApproved list is empty then\nloan status = NotActive
BContract -> BContract: emit event LoanApproved

== StartLoan ==

API -> BContract: Start loan
BContract -> BStorage: loan status = Active
note right
  Borrower can call "BorrowTokens" only
  when loan status = active
end note 
BContract -> BContract: emit event LoanStarted

== BorrowTokensOfLoan ==

Borrower -> BContract: Borrow Tokens: payable
loop through tokens in NotApproved list of loan states
  BContract -> BStorage: move the tokens to Declined list of loan states
  BContract -> BStorage: delete loan requests from owner's list
  BContract -> BStorage: set token's SaleType = Loan
end
loop through tokens in Approved list of loan states
  BContract -> BStorage: freeTransfer from owner to borrower 
end
note right
  There borrower has to pay for 2 operations:
  1. initial transfer to borrow tokens
  2. final transfer to return tokens to real owners
end note
BContract -> BContract: transfer half of ethereum sum to Snark's wallet\nto cover the cost of returning the tokens to owners

== StopLoan ==

API -> BContract: stop loan
loop through tokens in Approved list of loan states
  BContract -> BStorage: freeTrasfer: from borrower to owner
  BContract -> BStorage: set token's SaleType = None
end
BContract -> BStorage: loan status = Finished
BContract -> BContract: emit event LoanStoped

== DeclineTokenOfLoan ==

Owner -> BContract: call DeclineLoanToken
note right
  * can be performed only if loan status < Active
  * it is free, because the borrower did not leave money at this moment
  * it will also be called if the owner wants to create an Offer
    or accept a Bid until Loan is not in Active state
end note
BContract -> BStorage: delete from Approved list of loan
BContract -> BStorage: delete from token's calendar
BContract -> BStorage: delete token from a reques list
BContract -> BStorage: set token's SaleType = None
BContract -> BContract: emit event TokenDeclined

== DeleteLoan ==

Borrower -> BContract: deleteLoan
note right
  Can be performed by a Borrower only
end note
loop through tokens in Approved and Declined list of loan states
  BContract -> BStorage: delete from Approved list of loan
  BContract -> BStorage: delete from Declined list of loan
  BContract -> BStorage: delete token from a request list
  BContract -> BStorage: delete from token's calendar
  BContract -> BStorage: set token's SaleType = None
end
BContract -> BStorage: loan status = Finished
BContract -> BContract: emit event LoanDeleted

|||
@enduml
